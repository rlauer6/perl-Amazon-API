package Amazon::API;

# Generic interface to Amazon APIs

=pod

=head1 NAME

C<Amazon::API>

=head1 SYNOPSIS

 package Amazon::CloudWatchEvents;

 use parent qw/Amazon::API/;

 @API_METHODS = qw/
		  DeleteRule
		  DescribeEventBus
		  DescribeRule
		  DisableRule
		  EnableRule
		  ListRuleNamesByTarget
		  ListRules
		  ListTargetsByRule
		  PutEvents
		  PutPermission
		  PutRule
		  PutTargets
		  RemovePermission
		  RemoveTargets
		  TestEventPattern/;

 sub new {
   my $class = shift;
   my $options = shift || {};
 
   $class->SUPER::new({
 		      %$options,
 		      service_url_base => 'events',
 		      version          => undef,
 		      api              => 'AWSEvents',
 		      api_methods      => \@API_METHODS,
 		      content_type     => 'application/x-amz-json-1.1'
 		     });
 }

 1;

my $cwe = Amazon::CloudWatchEvents->new();

my $rules = $cwe->ListRules();


=head1 DESCRIPTION

Generic class to use for constructing AWS API interfaces.  Typically
used as the parent class, but can be used directly.

=over 5

=item * See L</IMPLEMENTATION NOTES> for using C<Amazon::API>
directly to call AWS services.

=item * See C<Amazon::CloudWatchEvents> for an example of use this module as a
parent class.

=back

=head1 BACKGROUND AND MOTIVATION

A comprehensive Perl interface to AWS services similar to the boto
library for Python has been a long time in coming. The PAWS project
has attempted to create an always up-to-date interface with community
support.  Some however may find that project a little heavy in the
dependency department. If you are looking for an extensible (albeit
spartan) method using a subset of services without consuming all of
CPAN you might want to consider C<Amazon::API>.

=head1 THE APPROACH

Essentially, most AWS APIs are RESTful services that adhere to a
common protocol.

=over 5

=item 1. Set HTTP headers to indicate the API and method to be invoked

=item 2. Set credentials in the header

=item 3. Set API specific headers

=item 4. Sign the request and set the signature in the header

=item 5. Send a payload of parameters for the method being invoked

=back

Specific details of each API call are well documented and early
services often deviated from some of these patterns or included
special parameters.  In any event, this module attempts to account for
most if not all of those nuances and provide a fairly generic way of
invoking these APIs in the most lightweight way as possible.

Of course, you get what you pay for, so you'll probably need to be
very familiar with the APIs you are calling and willng to RTFM on
Amazon's website.  However, the payoff is that you can probably use
this class to call any AWS API.

Think of this class as a DIY kit to invoke just the methods you need
to invoke for your AWS project.  A good example of creating a quick
and dirty interface to CloudWatch Events can be found here:

L<Amazon::CloudWatchEvents|https://github.com/rlauer6/perl-Amazon-CloudWatchEvents>


=head1 ERRORS

Errors encountered are returned as an C<Amazon::API::Error> exception
object.  See L<Amazon::API::Error>/

=cut

use strict;
use warnings;

use parent qw/Class::Accessor Exporter/;

use Amazon::API::Error;
use Amazon::Credentials;

use AWS::Signature4;
use Data::Dumper;
use HTTP::Request;
use JSON::PP qw {encode_json decode_json };
use LWP::UserAgent;
use Scalar::Util qw{ reftype };
use XML::LibXML::Simple qw{ XMLin };

$Data::Dumper::Pair = ':';
$Data::Dumper::Useqq = 1;
$Data::Dumper::Terse = 1;

__PACKAGE__->follow_best_practice;

__PACKAGE__->mk_accessors(
  qw{ action api api_methods version content_type
    http_method credentials response protocol
    region url service_url_base decode_always
    signer target user_agent debug last_action
    aws_access_key_id aws_secret_access_key token
    print_error raise_error error
    }
);

use vars qw/@EXPORT $VERSION/;

@EXPORT=qw/$VERSION/;

our $VERSION = '@PACKAGE_VERSION@'; $VERSION=~s/\-.*$//;

=pod

=head1 METHODS

=head2 new

 new( options )

=over 5

=item credentials (optional)

Accessing AWS services requires passing credentials that with
sufficient privileges to invoke those APIs that support the service.
This module supports three ways that you can provide those
credentials.  

=over 5

=item 1. Pass the credentials keys directly.

Pass the values for the keys below when call the C<new> method.

=over 10

=item aws_access_key_id

=item aws_secret_access_key

=item token

=back

=item 2. Pass a class that will provide the credential keys.

Pass a reference to a class that has I<getters> for the credential
keys. The class should supply C<get_{credential-key}> methods.

Pass the reference as C<credentials> in the constructor.

 my $api = Amazon::API->new({ credentials => $credentials_class, ... });

=item 3. Use the default C<Amazon::Credentials> class.

If you don't pass the credentials or pass a class that will supply
credentials, the module will use the C<Amazon::Credentials> class that
attempts to find credentials in the environment, your credentials
file, or the container or instance role.

This method of obtaining credentials is probably the easiest to use.

=item user_agent

Your own user agent object or by default C<LWP::UserAgent>.  Using
C<Furl>, if you have it avaiable may result in faster response.

=item api (reqired)

The name of the AWS service.  Example: AWSEvents

=item url

The service url.  Example: https://events.us-east-1.amazonaws.com

=item debug

0/1 - will dump request/response if set to true.

=item action

The API method. Example: PutEvents

=item content_type

Default content for paraemters passed to the C<invoke_api()> method.
The default is C<application/x-amz-json-1.1>.  If you are calling an
API that does not expect parameters (or all of them are optional and
you do not pass a parameter) the default will be to pass an empty
hash. 

  $cwe->ListRules();

would be equivalent to...

  $cwe->ListRules({});

=item protocol

One of 'http' or 'https'.  Some Amazon services do not support https
(yet).

=back

=cut

sub new {
  my $class = shift;
  $class = ref($class) || $class;
  
  my $self = $class->SUPER::new(@_);

  $self->set_raise_error(1) if !defined $self->get_raise_error;
  $self->set_print_error(1) if !defined $self->get_print_error;

  if (!$self->get_user_agent) {
    $self->set_user_agent(new LWP::UserAgent);
  }

  # legacy behavior is to never decode... :-(
  $self->set_decode_always(defined $self->get_decode_always || 0);
  
  # some APIs are GET only (I'm talkin' to you IAM!)
  $self->set_http_method($self->get_http_method // 'POST');
  
  # note some APIs are global, hence an API may send '' to indicate global
  $self->set_region($self->get_region // 'us-east-1');
  
  if ( !$self->get_credentials ) {
    if ( $self->get_aws_secret_access_key && $self->aws_access_key_id ) {

      $self->set_credentials(
        Amazon::Credentials->new(
          { aws_secret_access_key => $self->get_aws_secret_access_key,
            aws_access_key_id     => $self->get_aws_access_key_id,
            token                 => $self->get_token
          }
        )
      );
    } ## end if ( $self->get_aws_secret_access_key...)
    else {
      $self->set_credentials( Amazon::Credentials->new() );
    }
  } ## end if ( !$self->get_credentials)

  $self->set_protocol( $self->get_protocol() // 'https' );
  
  if ( !$self->get_url ) {
    if ( $self->get_service_url_base() ) {
      if ( $self->get_region ) {
        $self->set_url(
          sprintf(
            "%s://%s.%s.amazonaws.com",
            $self->get_protocol, $self->get_service_url_base,
            $self->get_region
          )
        );
      } ## end if ( $self->get_region)
      else {
        $self->set_url(
          sprintf(
            "%s://%s.amazonaws.com",
            $self->get_protocol, $self->get_service_url_base
          )
        );
      } ## end else [ if ( $self->get_region)]
    } ## end if ( $self->get_service_url_base...)
    else {
      die "ERROR: no url or service_url defined.\n";
    }
  } ## end if ( !$self->get_url )

  $self->set_signer(
    AWS::Signature4->new(
      -access_key => $self->get_credentials->get_aws_access_key_id,
      -secret_key => $self->get_credentials->get_aws_secret_access_key
    )
  );
 
  
  if ( $self->get_api_methods ) {
    no strict 'refs';
    no warnings 'redefine';
    
    foreach my $api (@{$self->get_api_methods}) {
      my $method = lcfirst $api;
      
      $method =~s/([a-z])([A-Z])/$1_$2/g;
      $method = lc $method;
      
      # snake case rules the day
      *{"Amazon::API::" . $method} = sub { shift->invoke_api("$api", @_) };
      # but some prefer camels
      *{"Amazon::API::" . $api} = sub { shift->$method(@_) }; # pass on to the snake
    }
  }
  
  $self->set_content_type('application/x-amz-json-1.1') unless
    $self->get_content_type;
  
  $self;
}

sub get_api_name {
  my $self = shift;
  
  return join("", map { ucfirst } split /_/, shift);
}

=pod

=head2 invoke_api

 invoke_api(action, [parameters, [content-type]]);

=over 5

=item action

=item parameters

Parameters to send to the API. Can be a scalar, a hash reference or an
array reference.

=item content-type

If you send the C<content-type>, it is assumed that the parameters are
the payload to be sent in the request.  Otherwise, the C<parameters>
will be converted to a JSON string if the C<parameters> value is a
hash reference or a query string if the C<parameters> value is an
array reference.

Hence, to send a query string, you should send an array key/value
pairs, or an array of scalars of the form Name=Value.

 [ { Action => 'DescribeInstances' } ]
 [ "Action=DescribeInstances" ]

...are both equivalent ways to force the method to send a query string.

=back

=cut

sub invoke_api {
  my $self = shift;
  my ($action, $parameters, $content_type) = @_;
  
  $self->set_action($action);
  $self->set_last_action($action);
  $self->set_error(undef);
  
  my $content;

  $content_type = $self->get_content_type
    if !$parameters && !$content_type;
  
  # guessing game...if you do not provide a content type
  if ( !$content_type ) {
    if ( ref($parameters) && reftype($parameters) eq 'HASH' ) {
      $content_type =  $self->get_content_type;
      $content = encode_json($parameters);
    }
    elsif ( ref($parameters) && reftype($parameters) eq 'ARRAY') {
      $content_type = 'application/x-www-form-url-encoded'
	if $self->get_http_method ne 'GET';
      
      my @query_string;
      foreach (@{$parameters}) {
	push @query_string, ref($_) ? sprintf("%s=%s", %$_) : $_;
      }
      
      $content = join('&', @query_string);
    }
    else {
      $content_type = 'application/x-www-form-url-encoded'
	unless $self->get_http_method eq 'GET';
      $content = $parameters;
    }
  }
  else {
    if ( $content_type =~/json/ && ref($parameters) ) {
      $content = encode_json($parameters);
    }
    elsif ($content_type =~/json/ && !$parameters ) {
      $content = encode_json({});
    }
    else {
      $content = $parameters;
    }
  }
   
  my $rsp = $self->submit(content => $content, content_type => $content_type);

  $self->set_response($rsp);
  
  if ( $self->get_debug ) {
    print STDERR Dumper [$rsp];
  }
    
  if ( !$rsp->is_success ) {
    $self->set_error(
      Amazon::API::Error->new(
        { error        => $rsp->code,
          message_raw  => $rsp->content,
          content_type => $rsp->content_type,
          api          => ref($self),
          response     => $rsp
        }
      )
    );

    $self->print_error if $self->get_print_error;

    if ( $self->get_raise_error ) {
      die $self->print_error;
    }
    else {
      return undef;
    }
  } ## end unless ( $rsp->is_success )
  
  return $self->get_decode_always ? $self->decode_response : $rsp->content;
}

sub print_error {
  my $self = shift;

  my $error = $self->get_error;
  my $err_str = 'API ERROR (' . $self->get_last_action . '): ';
  
  if ( $error && ref($error) =~ /Amazon::API::Error/ ) {
    my $response = $error->get_response;
    
    $err_str .= sprintf( "[%s], %s,%s\n",
      $error->get_error, Dumper( ref($response) ? $response : [ $response] ),
      $error->get_message_raw);
  }
  else {
    $err_str .= '[' . $error . ']';
  }
  
  return $err_str;
}

=pod

=head2 decode_response

Attempts to decode the response from the API based on the Content-Type
returned in the response header.  If there is no Content-Type, then
the raw content is returned.


=cut

sub decode_response {
  my $self = shift;
  my $rsp = $self->get_response;
  
  return undef unless $rsp;

  my $result = eval {
    if ( $rsp->content_type =~/xml/i) {
      XMLin($rsp->content);
    }
    elsif ( $rsp->content_type =~/json/i ) {
      decode_json($rsp->content);
    }
    else {
      $rsp->content;
    }
  };

  if ( $@ ) {
    $result = $rsp->content;
  }

  $result;
}


=pod

=head2 submit

 submit( options )

C<options> is hash of options:

=over 5

=item content

Payload to send.

=item content_type

Content types we have seen used to send values to AWS APIs:

 application/json
 application/x-amz-json-1.0
 application/x-amz-json-1.1
 application/x-www-form-urlencoded

=back

=cut

sub submit {
  my $self = shift;
  my %options = @_;

  my $request = HTTP::Request->new($self->get_http_method || 'POST', $self->get_url);

  # 1. set the header
  # 2. set the content
  # 3. sign the request
  # 4. send the request & return result
  
  # see IMPLEMENTATION NOTES for an explanation
  if ( $self->get_api ) {
    if ( $self->get_version) {
      $self->set_target(sprintf("%s_%s.%s", $self->get_api, $self->get_version, $self->get_action));
    }
    else {
      $self->set_target(sprintf("%s.%s", $self->get_api, $self->get_action));
    }

    $request->header('X-Amz-Target', $self->get_target());
  }
  
  unless ($self->get_http_method eq 'GET') {
    $options{content_type} = $options{content_type} || 'application/x-amz-json-1.1';
    $request->content_type($options{content_type});
    
    if ( $options{content_type} eq 'application/x-www-form-url-encoded') {
      $options{content} = $self->_finalize_content($options{content});
    }
    $request->content($options{content});
  }
  else {
    $request->uri(sprintf("%s?%s", $request->uri(), $self->_finalize_content($options{content})));
  }
  
  $request->header('X-Amz-Security-Token', $self->get_credentials->get_token)
    if $self->get_credentials->get_token;
		 
  # sign the request
  $self->get_signer->sign($request);

  # make the request, return response object
  if ( $self->get_debug ) {
    print STDERR Dumper([$request]);
  }
  
  $self->get_user_agent->request($request);
}

sub _finalize_content {
  my $self = shift;
  my $content = shift;
  
  my @args = $content if $content;
  
  if ( $content && $content !~/Action=/ || ! $content ) {
    push @args, "Action=" . $self->get_action;
  }
  
  if ( $self->get_version) {
    push @args, "Version=" . $self->get_version
  }
  
  return @args ? join('&', @args) : '';
}

=pod

=head1 IMPLEMENTATION NOTES

=head2 X-Amz-Target

Most of the newer AWS APIs accept a header (X-Amz-Target) in lieu of
the CGI parameter I<Action>. Some APIs also want the version in the
target, some don't. There is sparse documentation about the nuances of
using the REST interface directly to call AWS APIs.

We use the C<api> value as a trigger to indicate we need to set the
Action in the X-Amz-Target header.  We also check to see if the
version needs to be attached to the Action value as required by some
APIs.

  if ( $self->get_api ) {
    if ( $self->get_version) {
      $self->set_target(sprintf("%s_%s.%s", $self->get_api, $self->get_version, $self->get_action));
    }
    else {
      $self->set_target(sprintf("%s.%s", $self->get_api, $self->get_action));
    }

    $request->header('X-Amz-Target', $self->get_target());
  }


DynamoDB & KMS seems to be able to use this in lieu of query variables
Action & Version, although again, there seems to be a lot of
inconsisitency in the APIs.  DynamoDB uses DynamoDB_YYYYMMDD.Action
while KMS will not take the version that way and prefers
TrentService.Action (with no version).  There is no explanation in any
of the documentations I have been able to find as to what
"TrentService" might actually mean.

In general, the AWS API ecosystem is very organic. Each service seems
to have its own rules and protocol regarding what the content of the
headers should be.

This generic API interface tries to make it possible to use a central
class (Amazon::API) as a sort of gateway to the APIs. The most generic
interface is simply sending query variables and not much else in the
header.  APIs like EC2 conform to that protocol, so as indicated
above, we use C<action> to determine whether to send the API action in
the header or to assume that it is being sent as one of the query
variables.

=head2 Rolling a New API 

The class will stub out methods for the API if you pass an array of
API method names.  The stub is equivalent to:

 sub some_api {
   my $self = shift;

   $self ->invoke_api('SomeApi', @_);
 }

Some will also be happy to know that the class will create an
equivalent I<CamelCase> version of the method.  If you choose to
override the method, you should override the snake case version of the
method.

As an example, here is a possible implementation of
C<Amazon::CloudWatchEvents> that implements one of the API calls.

 package Amazon::CloudWatchEvents;

 use parent qw/Amazon::API/;
 
 sub new {
   my $class = shift;
   my $options = shift || {};

   $options->{api} 'AWSEvents';
   $options->{url} 'https://events.us-east-1.amazonaws.com';
   $options->{api_methods} => [ 'ListRules' ];

   return $class->SUPER::new($options);
 }

 1;

Then...

  my $cwe = new Amazon::CloudWatchEvents();
  $cwe->ListRules({});

Of course, creating a class for the service is optional. It may be
desirable however to create higher level and more convenient methods
that aid the developer in utilizing a particular API.

 my $api = new Amazon::API(
   { credentials => new Amazon::Credentials,
     api         => 'AWSEvents',
     url         => 'https://events.us-east-1.amazonaws.com'
   }
 );

$api->invoke_api( 'ListRules', {} );

=head2 Content-Type

Yet another piece of evidence that suggests the I<organic> nature of
the Amazon API ecosystem is their use of multiple forms of input to
their methods indicated by the required Content-Type for different
services.  Some of the variations include:

 application/json
 application/x-amz-json-1.0
 application/x-amz-json-1.1
 application/x-www-form-urlencoded

Accordingly, the C<invoke_api()> can be passed the Content-Type or
will try to make "best guess" based on the input parameter you passed.
It guesses using the following decision tree:

=over 5

=item * If the Content-Type parameter is passed as the third argument,
that is used.  Full stop.

=item * If the C<parameters> value to C<invoke_api()> is a reference,
then the Content-Type is either the value of C<get_content_type> or
C<application/x-amzn-json-1.1>.

=item * If the C<parameters> value to C<invoke_api()> is a scalar,
then the Content-Type is C<application/x-www-form-urlencoded>.

=back

You can set the default Content-Type used for the calling service when
a reference is passed to the C<invoke_api()> method by passing the
C<content_type> option to the constructor.

 $class->SUPER::new({%@_, content_type => 'application/x-amz-json-1.1', api => 'AWSEvents', 
                     url => 'https://events.us-east-1.amazonaws.com'});

=head1 SEE OTHER

C<Amazon::Credentials>, C<Amazon::API::Error>

=head1 AUTHOR

Rob Lauer - <rlauer6@comcast.net>

=cut

1;
